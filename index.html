<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Astronomick√° p≈ôedpovƒõƒè</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif;
      background-color: #eef2f5;
      padding: 20px;
      margin: 0;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #121212;
      color: #eee;
    }
    h1, h2 {
      text-align: center;
      margin-bottom: 15px;
      color: inherit;
    }
    .theme-toggle {
      text-align: center;
      margin-bottom: 20px;
    }
    .controls {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: center;
      transition: background 0.3s;
    }
    body.dark-mode .controls {
      background: #1e1e1e;
    }
    .input-container {
      flex: 1 1 250px;
      max-width: 100%;
      position: relative;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px 40px 10px 15px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      transition: border-color 0.3s, background 0.3s, color 0.3s;
    }
    body.dark-mode input[type="text"] {
      background: #333;
      color: #eee;
      border-color: #555;
    }
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s, transform 0.2s;
    }
    button:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }
    .clear-button {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 18px;
      color: #888;
      display: none;
      cursor: pointer;
    }
    .clear-button:hover { color: #000; }
    #suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      max-height: 200px;
      overflow-y: auto;
      z-index: 10;
      display: none;
      border-radius: 8px;
      transition: background 0.3s, color 0.3s;
    }
    body.dark-mode #suggestions {
      background: #333;
      color: #eee;
      border-color: #555;
    }
    #suggestions li {
      padding: 10px;
      list-style: none;
      cursor: pointer;
    }
    #suggestions li:hover, #suggestions li.active {
      background-color: #007bff;
      color: white;
    }
    #forecast {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      overflow-x: auto;
      transition: background 0.3s;
    }
    body.dark-mode #forecast {
      background: #1e1e1e;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 600px;
    }
    th, td {
      padding: 10px;
      border-bottom: 1px solid #eee;
      text-align: center;
    }
    body.dark-mode th, body.dark-mode td {
      border-color: #444;
    }
    tr:hover {
      background-color: #f9fafc;
    }
    body.dark-mode tr:hover {
      background-color: #2a2a2a;
    }
    .day-row {
      background-color: #dfe6ed;
      font-weight: bold;
    }
    body.dark-mode .day-row {
      background-color: #333;
    }
    .low-cloud { background-color: #d4edda; }
    .medium-cloud { background-color: #fff3cd; }
    .high-cloud { background-color: #f8d7da; }

    /* === ZV√ù≈†EN√ç KONTRASTU PRO NOƒåN√ç RE≈ΩIM === */
    body.dark-mode .low-cloud {
      background-color: #264d39;
      color: #d4edda;
    }
    body.dark-mode .medium-cloud {
      background-color: #4d4426;
      color: #fff3cd;
    }
    body.dark-mode .high-cloud {
      background-color: #4d2626;
      color: #f8d7da;
    }

    .hidden-row { display: none; }
    #loading-spinner {
      display: none;
      text-align: center;
      margin: 20px 0;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 5px solid #ccc;
      border-top: 5px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @media (max-width: 600px) {
      .controls { flex-direction: column; }
      th, td { font-size: 14px; }
    }
  </style>
</head>

<body>

<h1>Astronomick√° p≈ôedpovƒõƒè</h1>
<h2 id="cityDisplay"></h2>

<div class="theme-toggle">
  <button onclick="toggleTheme()">üåô P≈ôepnout re≈æim</button>
</div>

<div id="loading-spinner"><div class="spinner"></div></div>

<div class="controls">
  <div class="input-container">
    <input type="text" id="cityInput" placeholder="Zadejte mƒõsto (nap≈ô. Praha)" oninput="autocompleteCities()" onkeydown="handleSuggestionKeys(event)" autocomplete="off">
    <button class="clear-button" id="clearButton" onclick="clearInput()">√ó</button>
    <ul id="suggestions"></ul>
  </div>
  <button id="gpsButton" onclick="getLocation()">üìç Moje poloha</button>
  <button onclick="manualSearch()">üîç Zobrazit p≈ôedpovƒõƒè</button>
</div>

<div id="forecast">
  <table>
    <tbody></tbody>
  </table>
</div>

<script>
// === P≈ôep√≠n√°n√≠ t√©matu ===
function toggleTheme() {
  document.body.classList.toggle("dark-mode");
}

// === Glob√°ln√≠ promƒõnn√© ===
let sunriseTimes = {}, sunsetTimes = {};
let selectedCity = null;

// === Z√≠sk√°n√≠ n√°zvu dne ===
function getDayName(dateString) {
  const days = ['Nedƒõle', 'Pondƒõl√≠', '√öter√Ω', 'St≈ôeda', 'ƒåtvrtek', 'P√°tek', 'Sobota'];
  return days[new Date(dateString).getDay()];
}

// === P≈ôep√≠n√°n√≠ jednotliv√Ωch dn≈Ø ===
function toggleDay(cell, group) {
  const rows = document.querySelectorAll(`.group-${group}`);
  rows.forEach(row => row.classList.toggle('hidden-row'));
  cell.innerHTML = cell.innerHTML.includes('‚ñ∂Ô∏è') ?
    cell.innerHTML.replace('‚ñ∂Ô∏è', '‚ñº') :
    cell.innerHTML.replace('‚ñº', '‚ñ∂Ô∏è');
}

// === Emoji den/noc ===
function getSimpleTimeEmoji(hour, dateStr) {
  const sunrise = sunriseTimes[dateStr]?.split(':')[0];
  const sunset = sunsetTimes[dateStr]?.split(':')[0];
  if (!sunrise || !sunset) return '‚è≥';
  return (hour >= +sunrise && hour < +sunset) ? 'üåû' : 'üåô';
}

// === F√°ze Mƒõs√≠ce ===
function getMoonPhase(date) {
  const lp = 2551443;
  const now = new Date(date);
  const new_moon = new Date(2001,0,24,13,35);
  const phase = ((now.getTime() - new_moon.getTime()) / 1000) % lp;
  const age = Math.floor(phase / (24*3600));
  if (age < 1 || age >= 29) return ['üåë', 'Nov'];
  else if (age < 7) return ['üåí', 'Dor≈Østaj√≠c√≠ srpek'];
  else if (age < 10) return ['üåì', 'Prvn√≠ ƒçtvr≈•'];
  else if (age < 14) return ['üåî', 'Dor≈Østaj√≠c√≠ Mƒõs√≠c'];
  else if (age < 17) return ['üåï', '√öplnƒõk'];
  else if (age < 21) return ['üåñ', 'Couvaj√≠c√≠ Mƒõs√≠c'];
  else if (age < 25) return ['üåó', 'Posledn√≠ ƒçtvr≈•'];
  else return ['üåò', 'Ub√Ωvaj√≠c√≠ srpek'];
}

// === Naƒç√≠st p≈ôedpovƒõƒè ===
async function fetchForecast(lat, lon) {
  try {
    document.getElementById('loading-spinner').style.display = 'block';
    const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,cloudcover,precipitation,windspeed_10m&daily=sunrise,sunset&timezone=Europe/Prague`);
    if (!response.ok) throw new Error('HTTP chyba: ' + response.status);
    const data = await response.json();

    sunriseTimes = {}, sunsetTimes = {};
    (data.daily.sunrise || []).forEach(s => { const [d, t] = s.split('T'); sunriseTimes[d] = t; });
    (data.daily.sunset || []).forEach(s => { const [d, t] = s.split('T'); sunsetTimes[d] = t; });

    const { time = [], temperature_2m = [], cloudcover = [], precipitation = [], windspeed_10m = [] } = data.hourly || {};
    const tbody = document.querySelector('#forecast tbody');
    tbody.innerHTML = '';

    let currentDay = '';
    let group = 0;

    for (let i = 0; i < Math.min(time.length, 168); i++) {
      const [datePart, timePart] = time[i]?.split('T') || ['',''];
      const dayName = getDayName(datePart);
      const hour = parseInt(timePart?.split(':')[0], 10);
      const emoji = getSimpleTimeEmoji(hour, datePart);

      if (dayName !== currentDay) {
        currentDay = dayName;
        group++;

        const [moonEmoji, moonLabel] = getMoonPhase(datePart);
        const sunrise = sunriseTimes[datePart] || 'N/A';
        const sunset = sunsetTimes[datePart] || 'N/A';

        let dayLength = '';
        if (sunrise !== 'N/A' && sunset !== 'N/A') {
          const [srH, srM] = sunrise.split(':').map(Number);
          const [ssH, ssM] = sunset.split(':').map(Number);
          const totalMin = (ssH * 60 + ssM) - (srH * 60 + srM);
          const h = Math.floor(totalMin / 60), m = totalMin % 60;
          dayLength = `${h} h ${m} min`;
        }

        const dayRow = document.createElement('tr');
        dayRow.className = 'day-row';
        dayRow.innerHTML = `
          <td class="day-cell" onclick="toggleDay(this, ${group})" style="text-align: left; white-space: nowrap;">
          ‚ñ∂Ô∏è üìÖ ${dayName}<br>(${datePart})
          </td>
          <td colspan="5" style="text-align: left;">
         <div style="display: flex; gap: 30px;">
           <div>
             ‚òÄÔ∏è V√Ωchod: ${sunrise} / Z√°pad: ${sunset}<br>
             üåï F√°ze Mƒõs√≠ce: ${moonEmoji} ${moonLabel}<br>
             üï∞Ô∏è D√©lka dne: ${dayLength}
           </div>
          </div>
         </td>`;
        tbody.appendChild(dayRow);

        const headerRow = document.createElement('tr');
        headerRow.innerHTML = `
          <th>üïí ƒåas</th>
          <th>üåó Den/Noc</th>
          <th>üå°Ô∏è Teplota (¬∞C)</th>
          <th>‚òÅÔ∏è Oblaƒçnost (%)</th>
          <th>üåßÔ∏è Sr√°≈æky (mm)</th>
          <th>üí® V√≠tr (km/h)</th>
        `;
        tbody.appendChild(headerRow);
      }

      let cloudClass = '';
      if (cloudcover[i] <= 30) cloudClass = 'low-cloud';
      else if (cloudcover[i] <= 70) cloudClass = 'medium-cloud';
      else cloudClass = 'high-cloud';

      const row = document.createElement('tr');
      row.className = `${cloudClass.trim()} group-${group}`;
      row.innerHTML = `
        <td>${timePart}</td>
        <td>${emoji}</td>
        <td>${temperature_2m[i] ?? 'N/A'}</td>
        <td>${cloudcover[i] ?? 'N/A'}</td>
        <td>${precipitation[i] ?? 'N/A'}</td>
        <td>${windspeed_10m[i] ?? 'N/A'}</td>
      `;
      tbody.appendChild(row);
    }
  } catch (err) {
    console.error('Chyba:', err);
    alert('Nepoda≈ôilo se naƒç√≠st data.');
  } finally {
    document.getElementById('loading-spinner').style.display = 'none';
  }
}

// === Vyhled√°v√°n√≠ mƒõst ===
async function autocompleteCities() {
  const input = document.getElementById('cityInput').value.trim();
  const suggestions = document.getElementById('suggestions');
  const clearBtn = document.getElementById('clearButton');

  if (input.length < 2) {
    suggestions.style.display = 'none';
    clearBtn.style.display = 'none';
    return;
  }
  clearBtn.style.display = 'block';
  try {
    const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(input)}&count=5&language=cs&format=json`);
    const data = await res.json();
    const cities = data.results || [];

    suggestions.innerHTML = '';
    cities.forEach(city => {
      const li = document.createElement('li');
      li.textContent = `${city.name}, ${city.country}`;
      li.onclick = () => {
        selectedCity = city;
        document.getElementById('cityInput').value = `${city.name}, ${city.country}`;
        document.getElementById('suggestions').style.display = 'none';
        document.getElementById('cityDisplay').textContent = `${city.name}, ${city.country}`;
      };
      suggestions.appendChild(li);
    });

    suggestions.style.display = 'block';
  } catch (e) {
    console.error('Chyba autocomplete:', e);
    suggestions.style.display = 'none';
  }
}

function handleSuggestionKeys(event) {
  const suggestions = Array.from(document.querySelectorAll('#suggestions li'));
  let index = suggestions.findIndex(el => el.classList.contains('active'));
  if (event.key === 'ArrowDown') {
    event.preventDefault();
    if (index < suggestions.length - 1) {
      if (index >= 0) suggestions[index].classList.remove('active');
      suggestions[++index].classList.add('active');
    }
  } else if (event.key === 'ArrowUp') {
    event.preventDefault();
    if (index > 0) {
      suggestions[index].classList.remove('active');
      suggestions[--index].classList.add('active');
    }
  } else if (event.key === 'Enter') {
    event.preventDefault();
    if (index >= 0) suggestions[index].click();
  }
}

function clearInput() {
  document.getElementById('cityInput').value = '';
  document.getElementById('clearButton').style.display = 'none';
  document.getElementById('suggestions').style.display = 'none';
  selectedCity = null;
}

function manualSearch() {
  if (!selectedCity) {
    alert("Pros√≠m vyberte mƒõsto ze seznamu.");
    return;
  }
  fetchForecast(selectedCity.latitude, selectedCity.longitude);
}

function getLocation() {
  if (!navigator.geolocation) {
    alert('Geolokace nen√≠ podporov√°na t√≠mto prohl√≠≈æeƒçem.');
    return;
  }
  navigator.geolocation.getCurrentPosition(pos => {
    const { latitude, longitude } = pos.coords;
    document.getElementById('cityDisplay').textContent = `Va≈°e poloha (${latitude.toFixed(2)}, ${longitude.toFixed(2)})`;
    fetchForecast(latitude, longitude);
  }, () => {
    alert('Nepoda≈ôilo se z√≠skat polohu.');
  });
}
</script>

</body>
</html>
